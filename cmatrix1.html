<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Effect</title>
    <style>
        body {
            background: #000;
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
            background: linear-gradient(#010 0%, transparent 20%);
        }
    </style>
</head>
<body>
    <canvas id="matrix"></canvas>
    <script>
        'use strict';

        var matrix = document.getElementById('matrix');
        var ctx = matrix.getContext('2d');

        var config = {
            amount: 170,
            speed: 100,
            size: 15,
            minLength: 5,
            maxLength: 11,
            firstColor: '#fff',
            color: '#046',
            initialChars: "MATRIXYmatrixy"  // 처음 나타나는 글자들
        };

        var datarray = [];
        var width = ctx.canvas.width = window.innerWidth;
        var height = ctx.canvas.height = window.innerHeight;

        function Data(x) {
            this.x = x;
            this.y = 0;
            this.history = [];
            this.historySizeMax = Math.floor(Math.random() * config.maxLength + config.minLength);
        }

        Data.prototype = {
            update() {
                this.y += config.size;
                if (this.y >= height + this.historySizeMax * config.size) {
                    datarray.splice(datarray.indexOf(this), 1);
                    putData();
                }
                // 첫 글자는 "MATRIXY" 중 하나로 선택
                var firstChar = config.initialChars.charAt(Math.floor(Math.random() * config.initialChars.length));
                this.history.unshift(firstChar);

                // 이후 글자는 무작위 ASCII 문자
                if (this.history.length > this.historySizeMax) this.history.pop();
            },

            draw() {
                if (Math.random() > 0.995) return;
                
                ctx.fillStyle = config.firstColor;
                ctx.fillText(this.history[0], this.x, this.y);
                ctx.fillStyle = config.color;
                for (var i = 1, char; char = this.history[i]; i++) {
                    ctx.fillText(char, this.x, this.y - i * config.size);
                }
            }
        };

        var count = Math.floor(width / config.size);

        function putData() {
            var newX = Math.floor(Math.random() * count) * config.size;
            for (var i = 0, row; row = datarray[i]; i++) {
                if (row.x === newX && row.y - row.historySizeMax * config.size + config.size < config.size) return;
            }
            datarray.push(new Data(newX));
        }

        ctx.font = config.size + 'px monospace';
        ctx.shadowOffsetX = 1;
        ctx.shadowOffsetY = 1;
        ctx.shadowBlur = 6;
        ctx.shadowColor = config.color;

        function animate() {
            ctx.clearRect(0, 0, width, height);

            if (datarray.length < config.amount) putData();
            for (var i = 0, column; column = datarray[i]; i++) {
                column.update();
                column.draw();
            }

            setTimeout(animate, config.speed);
        }

        animate();
    </script>
</body>
</html>
